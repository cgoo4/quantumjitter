{
  "hash": "74ab431331fe662c24eb8586aba4ac1a",
  "result": {
    "markdown": "---\ntitle: \"Bootstraps & Bandings\"\ndate: \"2022-03-08\"\ncategories: [R, statistical inference, regex, special effects, web scraping]\ndescription: \"Decades-old residential property bands and inference using a sample of those recently sold\"\n---\n\n\n![](feature.jpg){fig-alt=\"A boot with a strap leans against a pile of ribbon-rolls\"}\n\nAre the residential property bands of [3 decades ago](https://www.gov.uk/guidance/understand-how-council-tax-bands-are-assessed#council-tax-bands-in-england-based-on-1-april-1991-values) becoming less so? Would a sample of those recently-sold reveal band convergence? And what may be inferred about those not sampled?\n\nOver the years, urban properties have been added to and divided up. And two streets of equal attractiveness, and with equivalently-banded properties, may have diverged as neighbourhoods evolved.\n\nWhilst properties can and do move to higher or lower bands following alteration, would a sample of those recently-sold reveal band convergence after so long? And what may be inferred about the wider housing stock?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(conflicted)\nlibrary(tidyverse)\nconflict_prefer_all(\"dplyr\")\nconflict_prefer(\"as_date\", \"lubridate\")\nlibrary(rvest)\nlibrary(scales)\nlibrary(SPARQL)\nlibrary(clock)\nconflict_prefer(\"date_format\", \"clock\")\nlibrary(RColorBrewer)\nlibrary(glue)\nlibrary(janitor)\nlibrary(infer)\nlibrary(tsibble)\nlibrary(ggfx)\nlibrary(usedthese)\n\nconflict_scout()\n```\n:::\n\n\nSetting the theme and colour palette for all graphics (with a little help from the [ggfx](https://ggfx.data-imaginist.com) package).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntheme_set(theme_bw())\n\ncol <- \"RdYlBu\"\n\nscale_fill_continuous <- \\(...) scale_fill_distiller(palette = col)\n\ncols <- brewer.pal(7, col)\n\ntibble(x = 1, y = 1, fill = 7:1) |> \n  ggplot(aes(x, y, fill = fill)) +\n  as_reference(geom_col(show.legend = FALSE), id = \"cols\") +\n  with_blend(\n    geom_text(\n      x = 1,\n      y = 3.5,\n      label = col,\n      size = 40,\n      fontface = \"bold\"\n    ),\n    bg_layer = \"cols\",\n    blend_type = \"atop\",\n    flip_order = TRUE,\n    id = \"text\"\n  ) +\n  with_outer_glow(\"text\", colour = \"white\") +\n  scale_fill_continuous() +\n  coord_flip() +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/theme-1.png){width=100%}\n:::\n:::\n\n\n[Property band](https://www.gov.uk/council-tax-bands) and [price-paid](https://landregistry.data.gov.uk/app/qonsole) data are separately sourced. The free-form street address is the only way to bring the two together. The structure, content and even spelling of the address sometimes differ, for example: \"FLAT C, 22 SOME STREET, SOME AREA, SW10 1AA\" in one may be \"22C 2ND FLR, HOUSE NAME, SOME STREET SW10 1AA\" in the other.\n\nSo, a little string manipulation is needed to create a common key. And reusable patterns will enable a consistent application to both.\n\n::: callout-tip\nHover over the numbered code annotation symbols for REGEX explanations.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nremove_pattern <-\n  str_c(\n    \", London, SW10 .+$\", # <1>\n    \"FLAT \",\n    \"APARTMENT \",\n    \"CHELSEA HARBOUR\",\n    \"(?<=COURT|SANDHILLS| HOUSE|WALK|ESTATE|ROW).*\", # <2>\n    \"[,'\\\\.]\",\n    \"(?<= )AT \",\n    \"(?<=VINT)N\",\n    \"(?<=FARRIER)S\",\n    \"(1ST|2ND|3RD|4TH|5TH|6TH) FLR \", # <3>\n    \"FLR (1ST|2ND|3RD|4TH|5TH|6TH) \", # <3>\n    \" ?- ?[0-9]{1,3}\",\n    sep = \"|\"\n  )\n\nswizzle_from <- \"^([0-9]{1,3})([A-Z])(?= .*)\" # <4>\nswizzle_to <- \"\\\\2 \\\\1\" # <4>\n```\n:::\n\n\n1.  Looks for *strings that end with 1 or more characters* following the London postcode district of \"SW10\".\n2.  Uses a [positive lookbehind](https://www.rexegg.com/regex-lookarounds.html) to find anything, for example, following the word `COURT` or `WALK` (since the postcode is stored in a separate variable and already isolates the road, so the road name is redundant).\n3.  Finds any occurrences of `1ST FLR`, `FLR 1ST` etc.\n4.  Uses [capture groups](https://www.rexegg.com/regex-capture.html) to temporarily memorise a number (capture group 1) followed by a letter (capture group 2), then swap them around. This is because a flat number may be `C22` in one dataset and `22C` in the other.\n\nCouncil Tax band data are available for non-commercial use[^1].\n\n[^1]: This data is licensed under the [Open Government Licence v3.0](https://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nurl1 <-\n  str_c(\n    \"https://www.tax.service.gov.uk/\",\n    \"check-council-tax-band/\",\n    \"search-council-tax-advanced?\",\n    \"postcode=Fkvms5WVQum-uX3L00_pcA&\",\n    \"filters.councilTaxBands=\"\n  )\n\nurl2 <- \"&filters.propertyUse=N&postcode=Fkvms5WVQum-uX3L00_pcA&page=\"\n\nurl3 <- \"&filters.bandStatus=Current\"\n\nindex <- crossing(band = LETTERS[1:8], page = seq(0, 120, 1))\n\nband_df <- map2(index$band, index$page, possibly(\\(i, j) {\n  str_c(url1, i, url2, j, url3) |>\n    read_html() |>\n    html_element(\"#search-results-table\") |>\n    html_table(convert = FALSE)\n}, otherwise = NA_character_)) |> \n  list_rbind()\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nband_df2 <- \n  band_df |> \n  clean_names() |> \n  mutate(postcode = str_extract(address, \"SW10 .+$\"),\n         raw_band_address = str_remove(address, \", London, SW10 .+$\"),\n         address = str_remove_all(address, remove_pattern),\n         address = str_replace(address, swizzle_from, swizzle_to),\n         address = str_squish(address)\n  )\n```\n:::\n\n\n[House price-paid](https://www.gov.uk/guidance/about-the-price-paid-data#explanations-of-column-headers-in-the-ppd) data are similarly available for non-commercial use[^2].\n\n[^2]: Contains HM Land Registry data © Crown copyright and database right 2021. This data is licensed under the [Open Government Licence v3.0](https://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nendpoint <- \"https://landregistry.data.gov.uk/landregistry/query\"\n\nquery <- '\nPREFIX  xsd:  <http://www.w3.org/2001/XMLSchema#>\nPREFIX  text: <http://jena.apache.org/text#>\nPREFIX  ppd:  <http://landregistry.data.gov.uk/def/ppi/>\nPREFIX  lrcommon: <http://landregistry.data.gov.uk/def/common/>\n\nSELECT  ?ppd_propertyAddress ?ppd_transactionCategory ?ppd_transactionDate ?ppd_pricePaid ?ppd_estateType ?ppd_propertyAddressCounty ?ppd_propertyAddressDistrict ?ppd_propertyAddressLocality ?ppd_propertyAddressPaon ?ppd_propertyAddressPostcode ?ppd_propertyAddressSaon ?ppd_propertyAddressStreet ?ppd_propertyAddressTown ?ppd_propertyType ?ppd_recordStatus\n\nWHERE\n  { { ?ppd_propertyAddress\n                text:query               ( lrcommon:postcode \"( SW10 )\" 3000000 ) .\n      ?item     ppd:propertyAddress      ?ppd_propertyAddress ;\n                ppd:transactionCategory  ppd:standardPricePaidTransaction ;\n                ppd:transactionDate      ?ppd_transactionDate ;\n                ppd:pricePaid            ?ppd_pricePaid ;\n      FILTER ( ?ppd_transactionDate >= \"2020-01-01\"^^xsd:date )\n    }\n    OPTIONAL{ ?item  ppd:estateType  ?ppd_estateType }\n    OPTIONAL{ ?ppd_propertyAddress lrcommon:county  ?ppd_propertyAddressCounty}\n    OPTIONAL{ ?ppd_propertyAddress lrcommon:district  ?ppd_propertyAddressDistrict}\n    OPTIONAL{ ?ppd_propertyAddress lrcommon:locality  ?ppd_propertyAddressLocality}\n    OPTIONAL{ ?ppd_propertyAddress lrcommon:paon  ?ppd_propertyAddressPaon}\n    OPTIONAL{ ?ppd_propertyAddress lrcommon:postcode  ?ppd_propertyAddressPostcode}\n    OPTIONAL{ ?ppd_propertyAddress lrcommon:saon  ?ppd_propertyAddressSaon}\n    OPTIONAL{ ?ppd_propertyAddress lrcommon:street  ?ppd_propertyAddressStreet}\n    OPTIONAL{ ?ppd_propertyAddress lrcommon:town  ?ppd_propertyAddressTown}\n    OPTIONAL{ ?item  ppd:propertyType  ?ppd_propertyType }\n    OPTIONAL{ ?item  ppd:recordStatus  ?ppd_recordStatus }\n    BIND(ppd:standardPricePaidTransaction AS ?ppd_transactionCategory)\n  }'\n\nprices_list <- SPARQL(endpoint, query)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprices_df2 <-\n  prices_list$results |>\n  as_tibble() |> \n  clean_names() |>\n  rename_with(~ str_remove_all(., \"ppd_|property_address_\")) |>\n  mutate(\n    transaction_date = as_datetime(transaction_date) |> as_date(),\n    price_paid = price_paid / 1000000\n  ) |>\n  filter(transaction_date < \"2022-01-01\") |>\n  mutate(\n    raw_price_address = str_c(str_replace_na(saon, \"\"), \n                              paon, street, sep = \" \") |> str_squish(),\n    address = str_remove_all(raw_price_address, remove_pattern),\n    address = str_replace(address, swizzle_from, swizzle_to)\n  ) |>\n  select(\n    address,\n    raw_price_address,\n    postcode,\n    price_paid,\n    transaction_date,\n    estate_type,\n    property_type,\n    transaction_category\n  )\n```\n:::\n\n\nNow there's a common key to join the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\njoined_df <-\n  prices_df2 |>\n  inner_join(band_df2, by = join_by(address, postcode)) |>\n  relocate(raw_band_address, .after = raw_price_address) |>\n  arrange(postcode, address) |>\n  mutate(council_tax_band = factor(council_tax_band))\n```\n:::\n\n\n\n\nAs with previous posts [Digging Deep](https://www.quantumjitter.com/project/planning/) and [House Sales](https://www.quantumjitter.com/project/sw10/), I'm focusing on postcodes in the SW10 part of London.\n\nIt's not possible to assess all SW10 properties by band since only a tiny fraction will have been sold recently. Recent sales could though be used as a sample and [Bootstrap Confidence Intervals](https://en.wikipedia.org/wiki/Bootstrapping_(statistics)) then employed to draw a wider inference.\n\n[\"Pulling yourself up by your bootstraps\"](https://www.huffingtonpost.co.uk/entry/pull-yourself-up-by-your-bootstraps-nonsense_n_5b1ed024e4b0bbb7a0e037d4) originally meant doing something absurd. Later it came to mean succeeding with only what you have at your disposal. Hence only the sample will be used as a surrogate for the true population by making repeated random draws from it (with replacement).\n\nA key assumption is that the sample is representative of the true population.\n\nEven though only recent sales transactions have been selected, a small movement in market prices will have occurred. So ensuring the bands are reasonably well distributed over the period is worthwhile.\n\n\n::: {.cell}\n\n```{.r .cell-code}\njoined_df |>\n  select(transaction_date, price_paid, council_tax_band) |>\n  mutate(yearquarter = yearquarter(transaction_date)) |>\n  count(yearquarter, council_tax_band) |>\n  ggplot(aes(yearquarter, n, fill = council_tax_band)) +\n  geom_col(position = position_fill()) +\n  scale_x_yearquarter() +\n  scale_y_continuous(labels = label_percent(1)) +\n  scale_fill_manual(values = cols[c(1:7)]) +\n  labs(\n    title = \"Distribution of Sales Transactions by Band & Quarter\",\n    x = \"Quarter\", y = \"Proportion\", fill = \"Band\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/distribution-1.png){width=100%}\n:::\n:::\n\n\nA violin plot of the property values by band shows some bimodal distribution and oddly shows bands E & F with lower mean prices than band D. This is worth closer inspection to ensure the sample is representative.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlabels <- joined_df |>\n  summarise(n = n(), mean_price = mean(price_paid),\n            .by = council_tax_band)\n\ntransactions <-\n  joined_df |>\n  count() |>\n  pull()\n\nfrom <- joined_df |>\n  summarise(min(transaction_date) |> yearquarter()) |>\n  pull()\n\nto <- joined_df |>\n  summarise(max(transaction_date) |> yearquarter()) |>\n  pull()\n\njoined_df |>\n  ggplot(aes(council_tax_band, price_paid)) +\n  geom_violin(fill = cols[1]) +\n  geom_label(aes(label = glue(\n    \"n = {n} \\nAvg Price \",\n    \"{dollar(mean_price, prefix = '£', suffix = 'm', accuracy = 0.01)}\"\n  ), y = 16),\n  data = labels, size = 2.3, alpha = 0.7, fill = \"white\"\n  ) +\n  scale_y_log10(labels = label_dollar(\n    prefix = \"£\",\n    suffix = \"m\", accuracy = 0.1\n  )) +\n  labs(\n    title = \"Droopy Bandings\",\n    subtitle = glue(\n      \"Sample of {transactions} Property \",\n      \"Transactions in SW10 ({from} to {to})\"\n    ),\n    x = \"Council Tax Band\", y = \"Sale Price (log10 scale)\",\n    caption = \"Sources: tax.service.gov.uk & landregistry.data.gov.uk\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/visualise-1.png){width=100%}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\njoined_df2 <- joined_df |>\n  mutate(`SW10 0JR` = if_else(postcode == \"SW10 0JR\", \"Yes\", \"No\"))\n```\n:::\n\n\nIt turns out that the unusual transactions below £0.3m are almost entirely from one postcode as shown below when isolating \"SW10 0JR\". This appears to be a single large new development with all sub-units sold in 2020.\n\nThese specific transactions feel somewhat unusual at these banding levels. And irrespective of their accuracy, a sample of 170 postcodes heavily dominated by the transactions of just one would not be representative of the true population.\n\n\n::: {.cell}\n\n```{.r .cell-code}\njoined_df2 |>\n  ggplot(aes(council_tax_band, price_paid, fill = `SW10 0JR`)) +\n  geom_violin() +\n  geom_label(aes(label = glue(\n    \"n = {n} \\nAvg Price\\n\",\n    \"{dollar(mean_price, prefix = '£', suffix = 'm', accuracy = 0.01)}\"\n  ), y = 16),\n  data = labels, size = 2.3, alpha = 0.7, fill = \"white\"\n  ) +\n  geom_hline(yintercept = 0.3, linetype = \"dashed\") +\n  scale_y_log10(labels = label_dollar(\n    prefix = \"£\",\n    suffix = \"m\", accuracy = 0.1\n  )) +\n  scale_fill_manual(values = cols[c(1, 5)]) +\n  labs(\n    title = \"Unusual Bandings\",\n    subtitle = glue(\n      \"Sample of {transactions} Property \",\n      \"Transactions in SW10 ({from} to {to})\"\n    ),\n    x = \"Council Tax Band\", y = \"Sale Price (log10 scale)\",\n    caption = \"Sources: tax.service.gov.uk & landregistry.data.gov.uk\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/anomaly-1.png){width=100%}\n:::\n\n```{.r .cell-code}\njoined_df2 |>\n  count(postcode, sort = TRUE) |>\n  slice_head(n = 10)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|postcode |  n|\n|:--------|--:|\n|SW10 0JR | 79|\n|SW10 0HQ | 10|\n|SW10 0AA |  7|\n|SW10 0HG |  6|\n|SW10 9AD |  6|\n|SW10 9JP |  6|\n|SW10 0DD |  5|\n|SW10 0UY |  5|\n|SW10 9BT |  5|\n|SW10 9JR |  5|\n\n</div>\n:::\n:::\n\n\nSo, I'll remove this postcode.\n\n\n::: {.cell}\n\n```{.r .cell-code}\njoined_df3 <- joined_df |> \n  filter(postcode != \"SW10 0JR\")\n```\n:::\n\n\nThis now feels like a representative sample of 314 property transactions. And broadly-speaking the plot shows a progression in average property values as we step through the bands. There is though substantial convergence between some, with the \"drippy\" band E still looking almost indistinguishable from band D.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlabels <- joined_df3 |>\n  summarise(n = n(), mean_price = mean(price_paid),\n            .by = council_tax_band)\n\ntransactions <-\n  joined_df3 |>\n  count() |>\n  pull()\n\njoined_df3 |>\n  ggplot(aes(council_tax_band, price_paid)) +\n  geom_violin(fill = cols[1]) +\n  geom_label(aes(label = glue(\n    \"n = {n} \\nAvg Price \",\n    \"{dollar(mean_price, prefix = '£', suffix = 'm', accuracy = 0.01)}\"\n  ), y = 16),\n  data = labels, size = 2.3, alpha = 0.7, fill = \"white\"\n  ) +\n  scale_y_log10(labels = label_dollar(prefix = \"£\", \n                                       suffix = \"m\", accuracy = 0.1)) +\n  labs(\n    title = \"Drippy Bandings\",\n    subtitle = glue(\n      \"Sample of {transactions} Property \",\n      \"Transactions in SW10 ({from} to {to})\"\n    ),\n    x = \"Council Tax Band\", y = \"Sale Price (log10 scale)\",\n    caption = \"Sources: tax.service.gov.uk & landregistry.data.gov.uk\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/drippy-1.png){width=100%}\n:::\n:::\n\n\nSome band E examples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\njoined_df3 |>\n  filter(council_tax_band == \"E\", price_paid >= 0.6) |>\n  select(\n    address = raw_price_address,\n    postcode,\n    transaction_date,\n    price_paid,\n    tax_band = council_tax_band,\n    estate_type,\n    property_type\n  ) |>\n  mutate(across(ends_with(\"type\"), \\(x) str_remove_all(x, \"^.*mon/|>$\"))) |> # <1>\n  select(-address)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|postcode |transaction_date | price_paid|tax_band |estate_type |property_type   |\n|:--------|:----------------|----------:|:--------|:-----------|:---------------|\n|SW10 0AN |2020-03-18       |    0.83000|E        |leasehold   |flat-maisonette |\n|SW10 0AP |2021-06-22       |    0.67500|E        |leasehold   |flat-maisonette |\n|SW10 0AW |2021-03-29       |    0.69500|E        |leasehold   |flat-maisonette |\n|SW10 0AX |2020-02-21       |    0.65000|E        |leasehold   |flat-maisonette |\n|SW10 0BG |2021-03-30       |    0.76500|E        |leasehold   |flat-maisonette |\n|SW10 0HP |2021-10-12       |    0.67500|E        |leasehold   |flat-maisonette |\n|SW10 0LB |2021-04-15       |    0.63000|E        |leasehold   |flat-maisonette |\n|SW10 0PE |2020-03-25       |    0.68000|E        |leasehold   |flat-maisonette |\n|SW10 9AD |2021-06-21       |    1.07500|E        |leasehold   |flat-maisonette |\n|SW10 9ED |2020-10-29       |    0.60000|E        |leasehold   |flat-maisonette |\n|SW10 9JX |2020-09-14       |    1.00000|E        |leasehold   |flat-maisonette |\n|SW10 9JY |2021-08-30       |    1.00000|E        |leasehold   |flat-maisonette |\n|SW10 9JY |2020-08-06       |    0.67950|E        |leasehold   |flat-maisonette |\n|SW10 9PJ |2020-12-14       |    0.68925|E        |leasehold   |flat-maisonette |\n\n</div>\n:::\n:::\n\n\n1.  Removes the URL wrapped around the estate and property types, i.e. \"\\<http://landregistry.data.gov.uk/def/common/\" before and \"\\>\" after the type.\n\nCan we infer that the true population of band Es no longer exhibits any difference in mean values with respect to band D?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbands_ef <- \n  joined_df3 |>\n  filter(council_tax_band %in% c(\"E\", \"D\"))\n\nobs_stat <- \n  bands_ef |> \n  specify(price_paid ~ council_tax_band) |>\n  calculate(stat = \"diff in means\", order = c(\"E\", \"D\")) |>\n  pull()\n\nset.seed(2)\n\nboot_dist <-\n  bands_ef |> \n  specify(price_paid ~ council_tax_band) |>\n  generate(reps = 2000, type = \"bootstrap\") |>\n  calculate(stat = \"diff in means\", order = c(\"E\", \"D\"))\n\nperc_ci <- get_ci(boot_dist)\n\nlower <- perc_ci |>\n  pull(lower_ci) |>\n  dollar(prefix = \"£\", suffix = \"m\", accuracy = 0.01)\nupper <- perc_ci |>\n  pull(upper_ci) |>\n  dollar(prefix = \"£\", suffix = \"m\", accuracy = 0.01)\n\nboot_dist |>\n  visualise() +\n  shade_confidence_interval(\n    endpoints = perc_ci,\n    color = cols[6], fill = cols[3]\n  ) +\n  geom_vline(xintercept = obs_stat, linetype = \"dashed\", colour = \"white\") +\n  annotate(\"label\",\n    x = -0.12, y = 350, size = 3,\n    label = glue(\n      \"Observed Difference\\nBetween Bands D & E is \",\n      \"{dollar(obs_stat, prefix = '£', suffix = 'm', accuracy = 0.01)}\"\n    )\n  ) +\n  scale_x_continuous(labels = label_dollar(\n    prefix = \"£\",\n    suffix = \"m\", accuracy = 0.1\n  )) +\n  labs(\n    subtitle = glue(\n      \"95% Confident the Difference \",\n      \"in Mean Prices Between Bands D & E is {lower} to {upper}\"\n    ),\n    x = \"Difference in Means\", y = \"Count\",\n    caption = \"Sources: tax.service.gov.uk & landregistry.data.gov.uk\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/infer-1.png){width=100%}\n:::\n:::\n\n\nBootstrapping with a 95% confidence interval suggests the true difference in mean prices between all band D and E properties in SW10 is somewhere in the range -£0.10m to £0.10m. Considerable convergence compared to [3 decades ago](https://www.gov.uk/guidance/understand-how-council-tax-bands-are-assessed#council-tax-bands-in-england-based-on-1-april-1991-values) when the band E minimum exceeded the band D maximum.\n\n## R Toolbox\n\nSummarising below the packages and functions used in this post enables me to separately create a [toolbox visualisation](/project/box) summarising the usage of packages and functions across all posts.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nused_here()\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"usedthese table table-striped\" style=\"margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Package </th>\n   <th style=\"text-align:left;\"> Function </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> RColorBrewer </td>\n   <td style=\"text-align:left;\"> brewer.pal[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SPARQL </td>\n   <td style=\"text-align:left;\"> SPARQL[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> base </td>\n   <td style=\"text-align:left;\"> c[5], factor[1], library[13], max[1], mean[2], min[1], readRDS[1], seq[1], set.seed[2] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> conflicted </td>\n   <td style=\"text-align:left;\"> conflict_prefer[2], conflict_prefer_all[1], conflict_scout[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> dplyr </td>\n   <td style=\"text-align:left;\"> across[1], arrange[1], count[4], filter[4], if_else[1], inner_join[1], join_by[1], mutate[7], n[2], pull[7], relocate[1], rename_with[1], select[5], slice_head[1], slice_sample[1], summarise[4] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ggfx </td>\n   <td style=\"text-align:left;\"> as_reference[1], with_blend[1], with_outer_glow[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ggplot2 </td>\n   <td style=\"text-align:left;\"> aes[8], annotate[1], coord_flip[1], geom_col[2], geom_hline[1], geom_label[3], geom_text[1], geom_violin[3], geom_vline[1], ggplot[5], labs[5], position_fill[1], scale_fill_continuous[1], scale_fill_distiller[1], scale_fill_manual[2], scale_x_continuous[1], scale_y_continuous[1], scale_y_log10[3], theme_bw[1], theme_set[1], theme_void[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> glue </td>\n   <td style=\"text-align:left;\"> glue[8] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> infer </td>\n   <td style=\"text-align:left;\"> calculate[2], generate[1], get_ci[1], shade_confidence_interval[1], specify[2], visualise[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> janitor </td>\n   <td style=\"text-align:left;\"> clean_names[2] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> lubridate </td>\n   <td style=\"text-align:left;\"> as_date[1], as_datetime[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> purrr </td>\n   <td style=\"text-align:left;\"> list_rbind[1], map2[1], possibly[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> rvest </td>\n   <td style=\"text-align:left;\"> html_element[1], html_table[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> scales </td>\n   <td style=\"text-align:left;\"> dollar[6], label_dollar[4], label_percent[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> stringr </td>\n   <td style=\"text-align:left;\"> str_c[4], str_extract[1], str_remove[1], str_remove_all[4], str_replace[2], str_replace_na[1], str_squish[2] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> tibble </td>\n   <td style=\"text-align:left;\"> as_tibble[1], tibble[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> tidyr </td>\n   <td style=\"text-align:left;\"> crossing[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> tidyselect </td>\n   <td style=\"text-align:left;\"> ends_with[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> tsibble </td>\n   <td style=\"text-align:left;\"> scale_x_yearquarter[1], yearquarter[3] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> usedthese </td>\n   <td style=\"text-align:left;\"> used_here[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> xml2 </td>\n   <td style=\"text-align:left;\"> read_html[1] </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"../../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}