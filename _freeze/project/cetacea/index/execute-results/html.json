{
  "hash": "2a53b75be14eadadb3db06889b607ca2",
  "result": {
    "markdown": "---\ntitle: \"Sea Monsters that Lost their Way\"\ndate: \"2021-12-04\"\ncategories: [R, geospatial, machine learning, textual analysis]\ndescription: \"Predicting uncertain species of cetacean strandings recorded by the Natural History Museum\"\nbibliography: references.bib\n---\n\n\n![](feature.gif){fig-alt=\"A buoy sways in the sea water in front of the coastal cliff. On it, a sign points left for dolphins and right for orca. And a dolphin and orca are seen in the foreground reading the sign.\"}\n\nThe Natural History Museum began recording cetacean (whales, dolphins and porpoises) strandings in 1913 [@naturalhistorymuseum2019]. Let's explore this 1913-1989 dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(conflicted)\nlibrary(tidyverse)\nconflict_prefer_all(\"dplyr\")\nlibrary(tidymodels)\nlibrary(probably)\nlibrary(finetune)\nlibrary(textrecipes)\nlibrary(stopwords)\nlibrary(wesanderson)\nlibrary(clock)\nlibrary(glue)\nlibrary(janitor)\nlibrary(vip)\nconflict_prefer(\"vi\", \"vip\")\nlibrary(tictoc)\nlibrary(patchwork)\nlibrary(doParallel)\nlibrary(usedthese)\n\nconflict_scout()\n\nregisterDoParallel(cores = 6)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntheme_set(theme_bw())\n\n(cols <- wes_palette(name = \"Darjeeling2\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/theme-1.png){width=100%}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstrandings_df <- read_csv(\"strandings.csv\", show_col_types = FALSE) |>\n  clean_names() |> \n  mutate(\n    date_rep = date_parse(date, format = \"%d/%m/%Y\"),\n    length = parse_number(length_et),\n    species_lumped = fct_lump_n(species, 20),\n    across(ends_with(\"_val\"), as.integer),\n    rep_comment = comment\n  )\n\n# glimpse(strandings_df)\n```\n:::\n\n\n## Exploratory\n\nSome of the `species` labels contain a question mark or forward slash. This indicates uncertainty, so it might be fun to see if a machine learning model (multi-class classification) could learn from the known species and suggest an appropriate `species` where it's uncertain.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstrandings_df2 <- \n  strandings_df |> \n  mutate(species_uncertainty =\n      if_else(str_detect(species, \"[?/]\"), \"Uncertain\", \"Known\"))\n\nstrandings_df2 |> \n  filter(species_uncertainty == \"Uncertain\") |> \n  count(species, sort = TRUE, name = \"Count\") |> \n  slice_head(n = 6)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|species              | Count|\n|:--------------------|-----:|\n|delphis/coeruleoalba |    48|\n|phocoena?            |    42|\n|melaena?             |    20|\n|delphis?             |    18|\n|truncatus?           |    18|\n|acutorostrata?       |    12|\n\n</div>\n:::\n:::\n\n\nThe `date` variable has many NA's. Fortunately, the components to construct many of these are in the `year_val`, `month_val` and `day_val` variables. With a little wrangling and imputation, we can coalesce these variables into a new date. This will be useful since plots of sample `species` by `year`, `month` and `week` of stranding suggest a de-constructed `date` could be a useful predictor.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstrandings_df2 |> \n  select(date_rep, year_val, month_val, day_val) |> \n  summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    date_rep             year_val      month_val         day_val     \n Min.   :1913-02-13   Min.   :   0   Min.   : 0.000   Min.   : 0.00  \n 1st Qu.:1933-09-09   1st Qu.:1933   1st Qu.: 4.000   1st Qu.: 9.00  \n Median :1954-04-13   Median :1955   Median : 7.000   Median :16.00  \n Mean   :1955-01-08   Mean   :1954   Mean   : 6.766   Mean   :15.66  \n 3rd Qu.:1979-03-21   3rd Qu.:1979   3rd Qu.:10.000   3rd Qu.:22.00  \n Max.   :1989-12-25   Max.   :1989   Max.   :12.000   Max.   :31.00  \n NA's   :121                                                         \n```\n:::\n\n```{.r .cell-code}\nstrandings_df3 <- strandings_df2 |>\n  mutate(\n    month_val = if_else(month_val == 0, mean(month_val) |> \n                          as.integer(), month_val),\n    day_val = if_else(day_val == 0, mean(day_val) |> as.integer(), day_val),\n    day_val = if_else(day_val == 0, 1L, day_val),\n    date2 = date_build(year_val, month_val, day_val, invalid = \"NA\"),\n    .by = species\n  ) |> \n  mutate(date3 = coalesce(date_rep, date2),\n         date_rep = if_else(is.na(date_rep), lag(date3), date3)\n         ) |> \n  select(-date2, -date3, -ends_with(\"_val\"))\n\nexample_species <-\n  c(\"musculus\", \"melas\", \"crassidens\", \"borealis\", \"coeruleoalba\")\n\nknown_species <- strandings_df3 |> \n  filter(species_uncertainty == \"Known\")\n\nplot_date_feature <- \\(var) {\n  known_species |>\n    mutate(\n      year = get_year(date_rep),\n      month = get_month(date_rep),\n      week = as_iso_year_week_day(date_rep) |> get_week()\n    ) |>\n    filter(species %in% example_species) |>\n    count(species, {{ var }}) |>\n    ggplot(aes(species, {{ var }})) +\n    geom_violin(\n      alpha = 0.7,\n      fill = cols[3],\n      show.legend = FALSE\n    ) +\n    coord_flip() +\n    labs(\n      title = glue(\"Variation in {str_to_title(as.character(var))}\",\n                   \" of Stranding for Known Species\"),\n      x = NULL, y = glue(\"{str_to_title(as.character(var))}\")\n    )\n}\n\nc(\"year\", \"month\", \"week\") |> \n  map(sym) |> \n  map(plot_date_feature) |> \n  wrap_plots(ncol = 1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/impute-1.png){width=100%}\n:::\n:::\n\n\nDo `latitude` and `longitude` carry useful predictive information?\n\nA geospatial visualisation of strandings shows some `species` do gravitate towards particular stretches of coastline, e.g. \"acutus\" and \"albirostris\" to the east, and \"coeruleoalba\" to the south-west.\n\nSome `species` may also be more prone to mass stranding, so something that indicates whether a `species` has such a history (in these data) may be worth including in the mix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuki <- map_data(\"world\", region = c(\"uk\", \"ireland\"))\n\nlabels <- c(\"Mass\", \"Single\")\n\nuki |> \n  ggplot() +\n  geom_map(aes(long, lat, map_id = region), map = uki, \n           colour = \"black\", fill = \"grey90\", size = 0.1) +\n  geom_jitter(aes(longitude, latitude, colour = mass_single, \n                  size = mass_single), \n              alpha = 0.5, data = known_species) +\n  facet_wrap(~ species_lumped, nrow = 3) +\n  coord_map(\"mollweide\") +\n  scale_size_manual(values = c(1, 0.5), labels = labels) +\n  scale_colour_manual(values = cols[c(3, 2)], labels = labels) +\n  theme_void() +\n  theme(legend.position = \"top\", \n        strip.text = element_text(colour = \"grey50\")) +\n  labs(title = \"Strandings by Species\", \n       colour = NULL, size = NULL)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/mass-1.png){width=100%}\n:::\n\n```{.r .cell-code}\n# Add history of mass stranding\nstrandings_df4 <- strandings_df3 |> \n  mutate(mass_possible = min(mass_single, na.rm = TRUE),\n         .by = species)\n```\n:::\n\n\nSome records are missing the `length` measurement of the mammal. Nonetheless, where present, this is likely to be predictive, and may help, for example, separate species labelled as \"delphis/coeruleoalba\" where the `length` is at the extreme ends of the \"delphis\" range as we see below. And the range of `length` may differ by mammal `sex`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknown_species |>\n  mutate(sex = case_match(\n    sex,\n    \"M\" ~ \"Male\",\n    \"F\" ~ \"Female\",\n    .default = \"Unknown\"\n  )) |> \n  filter(species_lumped != \"Other\") |> \n  count(species_lumped, length, sex) |> \n  mutate(species_lumped = fct_reorder(species_lumped, \n                                      desc(length), min, na.rm = TRUE)) |> \n  ggplot(aes(species_lumped, length)) + \n  geom_violin(aes(fill = if_else(str_detect(species_lumped, \"^de|^co\"), \n                                 TRUE, FALSE)), show.legend = FALSE) +\n  facet_wrap(~ sex) +\n  scale_fill_manual(values = cols[c(1, 5)]) +\n  coord_flip() +\n  labs(title = \"Variation in Species Length by Sex\", \n       x = NULL, y = \"Length (metres)\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/length-1.png){width=100%}\n:::\n:::\n\n\nWith map coordinates not always available, `county` could be, with a little string cleaning, a useful additional predictor.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstrandings_df4 |> \n  count(county) |> \n  filter(str_detect(county, \"Shet|Northumberland\")) |> \n  rename(County = county, Count = n)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|County                     | Count|\n|:--------------------------|-----:|\n|Fair Isle, Shetland Isles  |     1|\n|Northumberland             |    89|\n|Northumberland.            |     1|\n|Shetland Islands, Scotland |   232|\n|Shetland Isles, Scotland   |    35|\n|Shetland, Scotland         |     1|\n|Shetlands, Scotland        |     1|\n\n</div>\n:::\n\n```{.r .cell-code}\nregex_pattern <-\n  c(\"[,/].*$\",\n    \"(?<!Che|Hamp|Lanca|North York)-?shire\",\n    \" Isl.*$\",\n    \" &.*$\",\n    \"[-.]$\")\n\nstrandings_df5 <- strandings_df4 |>\n  mutate(\n    county = str_remove_all(county, str_c(regex_pattern, collapse = \"|\")),\n    county = recode(\n      county,\n      \"Carnarvon\" = \"Caernarvon\",\n      \"E.Lothian\" = \"East Lothian\",\n      \"Shetlands\" = \"Shetland\",\n      \"W.Glamorgan\" = \"West Glamorgan\",\n      \"S.Glamorgan\" = \"South Glamorgan\"\n    )\n  ) \n\nstrandings_df4 |>\n  summarise(counties_before = n_distinct(county))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| counties_before|\n|---------------:|\n|             146|\n\n</div>\n:::\n\n```{.r .cell-code}\nstrandings_df5 |>\n  summarise(counties_after = n_distinct(county))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| counties_after|\n|--------------:|\n|            109|\n\n</div>\n:::\n:::\n\n\nWhilst `count` also appears to hold, based on the plot pattern below, species-related information, I'm not going to use it as a predictor as we do not know enough about how it was derived, as reflected in these [variable descriptions](https://data.nhm.ac.uk/dataset/historical-uk-cetacean-strandings-dataset/resource/9a306dcd-1667-48b5-b682-ce6f071d85ce).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstrandings_df5 |>\n  ggplot(aes(species, count, colour = species_uncertainty)) +\n  geom_jitter(alpha = 0.5, size = 2) +\n  coord_flip() +\n  scale_y_log10() +\n  scale_colour_manual(values = cols[c(1, 5)]) +\n  labs(title = \"How 'Count' Relates to Species\", \n       x = NULL, y = \"Count (log10)\", colour = \"Species\") +\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/count-1.png){width=100%}\n:::\n:::\n\n\n## Modelling\n\nSo, I'll set aside the rows where the species is uncertain (to be used later for new predictions), and I'll train a model on 75% of known species, and test it on the remaining 25%. I'll use the following predictors:\n\n-   `latitude` and `longitude`\n-   Mammal `length` and `sex`\n-   `mass_possible` indicating a `species` history of mass strandings\n-   `date` reported converted into decimal, week, month and year\n-   `county` may be useful, especially where the longitude and latitude are missing\n-   `fam_genus` which narrows the range of likely species\n\nI'd like to also make use of the textrecipes[@textrecipes] package. I can tokenise the textual information in `rep_comment` and `location` to see if these add to the predictive power of the model.\n\nI'll tune the model using `tune_race_anova`[@finetune] which quickly discards hyperparameter combinations showing little early promise.\n\n\n::: {.cell hash='index_cache/html/model_14d201fd648095cd6b5f9716448d613b'}\n\n```{.r .cell-code}\nknown_species <- strandings_df5 |>\n  filter(species_uncertainty == \"Known\") |>\n  mutate(across(\n    c(\n      \"species\",\n      \"mass_single\",\n      \"mass_possible\",\n      \"county\",\n      \"location\",\n      \"sex\",\n      \"fam_genus\"\n    ),\n    factor\n  ))\n\nset.seed(123)\n\ndata_split <-\n  known_species |>\n  mutate(species = fct_drop(species)) |> \n  initial_split(strata = species)\n\ntrain <- data_split |> training()\n\ntest <- data_split |> testing()\n\npredictors <-\n  c(\n    \"latitude\",\n    \"longitude\",\n    \"length\",\n    \"mass_single\",\n    \"mass_possible\",\n    \"county\",\n    \"location\",\n    \"rep_comment\",\n    \"sex\",\n    \"fam_genus\"\n  )\n\nrecipe <-\n  train |>\n  recipe() |>\n  update_role(species, new_role = \"outcome\") |>\n  update_role(all_of(predictors), new_role = \"predictor\") |>\n  update_role(!has_role(\"outcome\") & !has_role(\"predictor\"), \n              new_role = \"id\") |>\n  step_date(date_rep, features = c(\"decimal\", \"week\", \"month\", \"year\"), \n            label = FALSE) |>\n  step_tokenize(location, rep_comment) |>\n  step_stopwords(location, rep_comment) |>\n  step_tokenfilter(location, rep_comment, max_tokens = tune()) |> #100\n  step_tf(location, rep_comment) |>\n  step_zv(all_predictors()) |>\n  step_dummy(all_nominal_predictors())\n\nxgb_model <-\n  boost_tree(trees = tune(), # 440\n             mtry = tune(), # 0.6\n             learn_rate = 0.02) |> \n  set_mode(\"classification\") |>\n  set_engine(\"xgboost\", \n             count = FALSE,\n             verbosity = 0,\n             tree_method = \"hist\")\n\nxgb_wflow <- workflow() |>\n  add_recipe(recipe) |>\n  add_model(xgb_model)\n\nset.seed(9)\n\nfolds <- vfold_cv(train, strata = species)\n\nset.seed(10)\n\ntic()\n\ntune_result <- xgb_wflow |>\n  tune_race_anova(\n    resamples = folds,\n    grid = crossing(\n      trees = seq(200, 520, 40),\n      mtry = seq(0.5, 0.7, 0.1),\n      max_tokens = seq(80, 120, 20)\n      ),\n    control = control_race(),\n    metrics = metric_set(accuracy)\n  )\n\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n396.407 sec elapsed\n```\n:::\n\n```{.r .cell-code}\ntune_result |> \n  plot_race() + \n  labs(title = \"Early Elimination of Parameter Combinations\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/model-1.png){width=100%}\n:::\n\n```{.r .cell-code}\nset.seed(123)\n\nxgb_fit <- xgb_wflow |>\n  finalize_workflow(tune_result |> \n                      select_best(metric = \"accuracy\")) |> \n  fit(train)\n```\n:::\n\n\nHaving fitted the model with the 3080 records in the training data, I'll test its accuracy on the 1028 records of *known* species the model has not yet seen.\n\nWithout spending time on alternative models, we're getting a reasonable result for the \"porpoise\" of this post, as reflected in both the accuracy metric and confusion matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxgb_results <- xgb_fit |> \n  augment(new_data = test)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[14:40:54] WARNING: src/learner.cc:553: \n  If you are loading a serialized model (like pickle in Python, RDS in R) generated by\n  older XGBoost, please export the model by calling `Booster.save_model` from that version\n  first, then load it back in current version. See:\n\n    https://xgboost.readthedocs.io/en/latest/tutorials/saving_model.html\n\n  for more details about differences between saving model and serializing.\n```\n:::\n\n```{.r .cell-code}\nxgb_results |>\n  accuracy(species, .pred_class)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|.metric  |.estimator | .estimate|\n|:--------|:----------|---------:|\n|accuracy |multiclass | 0.9931907|\n\n</div>\n:::\n\n```{.r .cell-code}\nxgb_results |>\n  conf_mat(species, .pred_class) |>\n  autoplot(type = \"heatmap\") +\n  scale_fill_gradient2(\n    mid = \"white\",\n    high = cols[1],\n    midpoint = 0\n  ) +\n  labs(title = \"Confusion Matrix\") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/results-1.png){width=100%}\n:::\n:::\n\n\nThe top variable importance scores include `fam_genus`, many of the `rep_comment` tokens, plus `length`, `mass-possible`, `date_decimal`, `date_year`, and `latitude`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvi(xgb_fit |> extract_fit_parsnip()) |> \n  arrange(desc(Importance)) |> \n  mutate(ranking = row_number()) |> \n  slice_head(n = 40)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|Variable                    | Importance| ranking|\n|:---------------------------|----------:|-------:|\n|fam_genus_Phocoena          |  0.1215845|       1|\n|fam_genus_Globicephala      |  0.0816541|       2|\n|tf_rep_comment_unidentified |  0.0736307|       3|\n|fam_genus_Delphinus         |  0.0710860|       4|\n|fam_genus_Tursiops          |  0.0500141|       5|\n|tf_rep_comment_false        |  0.0498405|       6|\n|fam_genus_Lagenorhynchus    |  0.0448997|       7|\n|tf_rep_comment_finned       |  0.0341306|       8|\n|tf_rep_comment_sided        |  0.0302409|       9|\n|tf_rep_comment_long         |  0.0244866|      10|\n|fam_genus_Hyperoodon        |  0.0240353|      11|\n|length                      |  0.0230962|      12|\n|fam_genus_Grampus           |  0.0227513|      13|\n|tf_rep_comment_beaked       |  0.0219021|      14|\n|tf_rep_comment_lesser       |  0.0215853|      15|\n|tf_rep_comment_rorqual      |  0.0199182|      16|\n|tf_rep_comment_dolphin      |  0.0198597|      17|\n|fam_genus_Orcinus           |  0.0194480|      18|\n|tf_rep_comment_porpoise     |  0.0192418|      19|\n|tf_rep_comment_bottle       |  0.0165892|      20|\n|fam_genus_Pseudorca         |  0.0159957|      21|\n|fam_genus_Physeter          |  0.0159090|      22|\n|tf_rep_comment_risso's      |  0.0131135|      23|\n|mass_possible_S             |  0.0127573|      24|\n|fam_genus_Mesoplodon        |  0.0123743|      25|\n|tf_rep_comment_fin          |  0.0122737|      26|\n|fam_genus_Ziphius           |  0.0122521|      27|\n|fam_genus_odontocete        |  0.0109274|      28|\n|fam_genus_cetacean          |  0.0104412|      29|\n|tf_rep_comment_killer       |  0.0099741|      30|\n|fam_genus_Stenella          |  0.0087018|      31|\n|date_rep_decimal            |  0.0081614|      32|\n|tf_rep_comment_nosed        |  0.0075943|      33|\n|date_rep_year               |  0.0072361|      34|\n|tf_rep_comment_whale        |  0.0071684|      35|\n|tf_rep_comment_white        |  0.0067214|      36|\n|mass_single_S               |  0.0041988|      37|\n|tf_rep_comment_common       |  0.0041767|      38|\n|tf_rep_comment_cuvier's     |  0.0036603|      39|\n|tf_rep_comment_sowerby's    |  0.0036372|      40|\n\n</div>\n:::\n:::\n\n\nDo the predictions look reasonable?\n\nThe class probability is spread across 27 species. I'm going to set a high threshold of 0.9, meaning the predicted species needs to be a pretty confident prediction.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxgb_preds <- xgb_fit |> \n  augment(new_data = strandings_df5 |> \n            filter(species_uncertainty == \"Uncertain\"))\n\nspecies_levels <- xgb_preds |> \n  select(starts_with(\".pred_\"), -.pred_class) |> \n  names() |> \n  as.factor()\n\nsubset_df <- xgb_preds |>\n  mutate(\n    .class_pred = make_class_pred(\n      .pred_acutorostrata,\n      .pred_acutus,\n      .pred_albirostris,\n      .pred_ampullatus,\n      .pred_bidens,\n      .pred_borealis,\n      .pred_breviceps,\n      .pred_cavirostris,\n      .pred_coeruleoalba,\n      .pred_crassidens,\n      .pred_delphis,\n      .pred_electra,\n      .pred_europaeus,\n      .pred_griseus,\n      .pred_leucas,\n      .pred_macrocephalus,\n      .pred_melaena,\n      .pred_melas,\n      .pred_mirus,\n      .pred_monoceros,\n      .pred_musculus,\n      .pred_novaeangliae,\n      .pred_orca,\n      .pred_phocoena,\n      .pred_physalus,\n      .pred_sp.indet.,\n      .pred_truncatus,\n      levels = levels(species_levels),\n      min_prob = .9\n    )\n  )\n\nsubset_df |>\n  summarise(n = n(), .by = c(species, .class_pred)) |> \n  arrange(species, desc(n)) |> \n  rename(\"Actual\" = species, \"Predicted\" = .class_pred, \"Count\" = n)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|Actual                 |           Predicted| Count|\n|:----------------------|-------------------:|-----:|\n|acutorostrata/borealis | .pred_acutorostrata|     1|\n|acutorostrata?         | .pred_acutorostrata|    12|\n|acutus?                |        .pred_acutus|     3|\n|albirostris?           |   .pred_albirostris|     9|\n|ampullatus?            |    .pred_ampullatus|     3|\n|bidens?                |        .pred_bidens|     2|\n|bidens?                |                [EQ]|     1|\n|cavirostris?           |   .pred_cavirostris|     7|\n|coeruleoalba?          |  .pred_coeruleoalba|     1|\n|delphis/coeruleoalba   |                [EQ]|    48|\n|delphis?               |       .pred_delphis|    18|\n|griseus?               |       .pred_griseus|     2|\n|macrocephalus?         | .pred_macrocephalus|     2|\n|melaena?               |       .pred_melaena|    20|\n|orca?                  |          .pred_orca|     4|\n|phocoena?              |      .pred_phocoena|    42|\n|physalus/acutorostrata |                [EQ]|     1|\n|physalus?              |      .pred_physalus|     4|\n|truncatus/albirostris  |                [EQ]|     5|\n|truncatus?             |     .pred_truncatus|    18|\n\n</div>\n:::\n:::\n\n\nThe majority of the 203 uncertain records are predicted to be as suspected in the original labelling. The remainder are classed as equivocal as they have not met the high bar of a 0.9-or-above probability for a single species.\n\n## R Toolbox\n\nSummarising below the packages and functions used in this post enables me to separately create a [toolbox visualisation](/project/box) summarising the usage of packages and functions across all posts.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nused_here()\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"usedthese table table-striped\" style=\"margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Package </th>\n   <th style=\"text-align:left;\"> Function </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> base </td>\n   <td style=\"text-align:left;\"> as.character[2], as.integer[2], c[13], is.na[1], levels[1], library[16], mean[2], min[1], names[1], seq[3], set.seed[4], summary[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> clock </td>\n   <td style=\"text-align:left;\"> as_iso_year_week_day[1], date_build[1], date_parse[1], get_month[1], get_week[1], get_year[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> conflicted </td>\n   <td style=\"text-align:left;\"> conflict_prefer[1], conflict_prefer_all[1], conflict_scout[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> doParallel </td>\n   <td style=\"text-align:left;\"> registerDoParallel[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> dplyr </td>\n   <td style=\"text-align:left;\"> across[2], arrange[2], case_match[1], coalesce[1], count[4], desc[3], filter[7], if_else[6], lag[1], mutate[13], n[1], n_distinct[2], recode[1], rename[2], row_number[1], select[3], slice_head[2], starts_with[1], summarise[3] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> finetune </td>\n   <td style=\"text-align:left;\"> control_race[1], plot_race[1], tune_race_anova[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> forcats </td>\n   <td style=\"text-align:left;\"> fct_drop[1], fct_lump_n[1], fct_reorder[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> generics </td>\n   <td style=\"text-align:left;\"> as.factor[1], augment[2], fit[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ggplot2 </td>\n   <td style=\"text-align:left;\"> aes[6], autoplot[1], coord_flip[3], coord_map[1], element_text[2], facet_wrap[2], geom_jitter[2], geom_map[1], geom_violin[2], ggplot[4], labs[6], map_data[1], scale_colour_manual[2], scale_fill_gradient2[1], scale_fill_manual[1], scale_size_manual[1], scale_y_log10[1], theme[3], theme_bw[1], theme_set[1], theme_void[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> glue </td>\n   <td style=\"text-align:left;\"> glue[2] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> hardhat </td>\n   <td style=\"text-align:left;\"> extract_fit_parsnip[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> janitor </td>\n   <td style=\"text-align:left;\"> clean_names[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> parsnip </td>\n   <td style=\"text-align:left;\"> boost_tree[1], set_engine[1], set_mode[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> patchwork </td>\n   <td style=\"text-align:left;\"> wrap_plots[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> probably </td>\n   <td style=\"text-align:left;\"> make_class_pred[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> purrr </td>\n   <td style=\"text-align:left;\"> map[2] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> readr </td>\n   <td style=\"text-align:left;\"> parse_number[1], read_csv[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> recipes </td>\n   <td style=\"text-align:left;\"> all_nominal_predictors[1], all_predictors[1], has_role[2], recipe[1], step_date[1], step_dummy[1], step_zv[1], update_role[3] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> rsample </td>\n   <td style=\"text-align:left;\"> initial_split[1], testing[1], training[1], vfold_cv[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> stringr </td>\n   <td style=\"text-align:left;\"> str_c[1], str_detect[3], str_remove_all[1], str_to_title[2] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> textrecipes </td>\n   <td style=\"text-align:left;\"> step_stopwords[1], step_tf[1], step_tokenfilter[1], step_tokenize[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> tictoc </td>\n   <td style=\"text-align:left;\"> tic[1], toc[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> tidyr </td>\n   <td style=\"text-align:left;\"> crossing[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> tidyselect </td>\n   <td style=\"text-align:left;\"> all_of[1], ends_with[2] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> tune </td>\n   <td style=\"text-align:left;\"> finalize_workflow[1], select_best[1], tune[3] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> usedthese </td>\n   <td style=\"text-align:left;\"> used_here[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> vip </td>\n   <td style=\"text-align:left;\"> vi[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> wesanderson </td>\n   <td style=\"text-align:left;\"> wes_palette[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> workflows </td>\n   <td style=\"text-align:left;\"> add_model[1], add_recipe[1], workflow[1] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> yardstick </td>\n   <td style=\"text-align:left;\"> accuracy[1], conf_mat[1], metric_set[1] </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"../../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}